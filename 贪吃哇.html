<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è´ªåƒçš„ä½  - ä¹æ®Šé­ç­–geminiè‡ªå®šä¹‰ç‰ˆ</title>
    <!-- å¼•å…¥ TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #game-container { position: relative; }
        #game-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(5px);
        }
        .control-btn { -webkit-tap-highlight-color: transparent; }
        input:disabled {
            cursor: not-allowed;
            background-color: #374151; /* bg-gray-700 */
            opacity: 0.5;
        }
    </style>
</head>
<body class="bg-gray-800 text-white min-h-screen flex flex-col items-center justify-center p-4 font-mono select-none">

    <div class="w-full max-w-sm md:max-w-md">
        <!-- æ¸¸æˆå¤´éƒ¨ -->
        <header class="flex justify-between items-center w-full mb-4">
            <h1 class="text-2xl font-bold text-green-400">è´ªåƒçš„ä½ </h1>
            <div class="text-lg">
                å¾—åˆ†: <span id="score" class="font-bold text-yellow-400">0</span>
            </div>
        </header>

        <!-- ã€ä¿®æ”¹ç‚¹ 2ã€‘è‡ªå®šä¹‰è®¾ç½®åŒºåŸŸ (æ–°å¸ƒå±€) -->
        <div id="settings-panel" class="mb-4 space-y-3">
            <!-- ç¬¬ä¸€æ’: è¾¹é•¿ å’Œ é€Ÿåº¦ -->
            <div class="grid grid-cols-2 gap-3">
                <div>
                    <!-- ã€ä¿®æ”¹ç‚¹ 1ã€‘åœ°å›¾è¾¹é•¿è®¾ç½® -->
                    <label for="tile-count-input" class="block text-center text-sm font-bold mb-1 text-gray-400">åœ°å›¾è¾¹é•¿ (6 ~ 12)</label>
                    <input type="number" id="tile-count-input" min="6" max="12" step="1" value="8" class="w-full bg-gray-700 border border-gray-600 rounded-lg text-center py-2 transition focus:border-green-500 focus:ring-green-500">
                </div>
                <div>
                    <label for="speed-input" class="block text-center text-sm font-bold mb-1 text-gray-400">æ¸¸æˆé€Ÿåº¦ (0.1 ~ 5.0)</label>
                    <input type="number" id="speed-input" min="0.1" max="5.0" step="0.01" value="1.5" class="w-full bg-gray-700 border border-gray-600 rounded-lg text-center py-2 transition focus:border-green-500 focus:ring-green-500">
                </div>
            </div>
            <!-- ç¬¬äºŒæ’: å›¾æ ‡URL -->
            <div class="grid grid-cols-2 gap-3">
                <div>
                    <label for="player-icon-input" class="block text-center text-sm font-bold mb-1 text-gray-400">ä½ çš„å›¾æ ‡ (URL)</label>
                    <input type="text" id="player-icon-input" placeholder="é»˜è®¤ä¸º ğŸ¸" class="w-full bg-gray-700 border border-gray-600 rounded-lg text-center px-2 py-2 text-sm transition focus:border-green-500 focus:ring-green-500">
                </div>
                <div>
                    <label for="food-icon-input" class="block text-center text-sm font-bold mb-1 text-gray-400">é£Ÿç‰©å›¾æ ‡ (URL)</label>
                    <input type="text" id="food-icon-input" placeholder="é»˜è®¤ä¸º ğŸ¦Ÿ" class="w-full bg-gray-700 border border-gray-600 rounded-lg text-center px-2 py-2 text-sm transition focus:border-green-500 focus:ring-green-500">
                </div>
            </div>
        </div>

        <!-- æ¸¸æˆå®¹å™¨ -->
        <div id="game-container" class="w-full aspect-square rounded-lg overflow-hidden shadow-2xl shadow-green-500/20">
            <canvas id="gameCanvas" class="bg-gray-900"></canvas>
            <div id="game-overlay" class="flex flex-col items-center justify-center text-center p-8">
                <h2 id="status-title" class="text-4xl font-extrabold mb-2 text-white">å‡†å¤‡å¥½äº†å—?</h2>
                <p id="status-subtitle" class="text-gray-300 mb-6">è‡ªå®šä¹‰è®¾ç½®ï¼Œç„¶åå¼€å§‹æ¸¸æˆ</p>
                <button id="start-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-xl transition-transform transform hover:scale-105 focus:outline-none">
                    å¼€å§‹æ¸¸æˆ
                </button>
            </div>
        </div>

        <!-- è§¦æ‘¸æ§åˆ¶æŒ‰é’® -->
        <div id="touch-controls" class="flex flex-col items-center gap-3 mt-6 w-full max-w-xs mx-auto">
            <div class="w-full flex justify-center"><button id="btn-up" class="control-btn bg-gray-700 p-4 rounded-lg w-16 h-16 flex items-center justify-center active:bg-green-500"> <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg> </button></div>
            <div class="w-full flex justify-between"><button id="btn-left" class="control-btn bg-gray-700 p-4 rounded-lg w-16 h-16 flex items-center justify-center active:bg-green-500"> <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg> </button><button id="btn-down" class="control-btn bg-gray-700 p-4 rounded-lg w-16 h-16 flex items-center justify-center active:bg-green-500"> <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg> </button><button id="btn-right" class="control-btn bg-gray-700 p-4 rounded-lg w-16 h-16 flex items-center justify-center active:bg-green-500"> <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg> </button></div>
        </div>
    </div>

    <script>
        // --- DOM å…ƒç´ è·å– ---
        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const gameOverlay = document.getElementById('game-overlay'), startBtn = document.getElementById('start-btn');
        const statusTitle = document.getElementById('status-title'), statusSubtitle = document.getElementById('status-subtitle');
        const speedInput = document.getElementById('speed-input');
        const playerIconInput = document.getElementById('player-icon-input');
        const foodIconInput = document.getElementById('food-icon-input');
        const tileCountInput = document.getElementById('tile-count-input'); // æ–°å¢

        // --- æ¸¸æˆé…ç½® ---
        const BASE_SPEED = 4.2;
        let tileCount, canvasSize, gridSize; // gridSize ä»å¸¸é‡å˜ä¸ºåŠ¨æ€è®¡ç®—çš„å˜é‡

        // --- æ¸¸æˆçŠ¶æ€ ---
        let snake, food, dx, dy, score, gameState, gameSpeed, lastRenderTime = 0;
        let playerImage = null, foodImage = null;

        // --- åˆå§‹åŒ–é«˜æ¸…ç”»å¸ƒå°ºå¯¸ ---
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const size = document.getElementById('game-container').clientWidth;
            
            // ã€ä¿®æ”¹ç‚¹ 1ã€‘ä»è¾“å…¥æ¡†è¯»å–åœ°å›¾è¾¹é•¿ï¼Œå¹¶è®¡ç®—æ¯ä¸ªæ ¼å­çš„åƒç´ å¤§å°
            tileCount = Math.max(6, Math.min(12, parseInt(tileCountInput.value) || 8));
            gridSize = size / tileCount; // åŠ¨æ€è®¡ç®—æ ¼å­åƒç´ å°ºå¯¸

            canvas.width = Math.round(size * dpr);
            canvas.height = Math.round(size * dpr);
            canvas.style.width = `${size}px`;
            canvas.style.height = `${size}px`;
            ctx.scale(dpr, dpr);

            canvasSize = size;
        }

        // --- æ¸¸æˆåˆå§‹åŒ–/é‡ç½® ---
        function init() {
            snake = [{ x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }];
            dx = dy = score = 0;
            const speedMultiplier = Math.max(0.1, Math.min(5.0, parseFloat(speedInput.value) || 1.5));
            gameSpeed = BASE_SPEED * speedMultiplier;
            updateScoreDisplay();
            generateFood();
        }

        // --- æ¸¸æˆä¸»å¾ªç¯ ---
        function gameLoop(currentTime) {
            if (gameState !== 'running') return;
            window.requestAnimationFrame(gameLoop);
            const secondsSinceLastRender = (currentTime - lastRenderTime) / 1000;
            if (secondsSinceLastRender < 1 / gameSpeed) return;
            lastRenderTime = currentTime;
            update();
            draw();
        }

        // --- æ›´æ–°ä¸ç»˜åˆ¶ ---
        function update() { moveSnake(); checkCollision(); }
        function draw() {
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, canvasSize, canvasSize);
            drawFood();
            drawSnake();
        }

        // --- ç§»åŠ¨è›‡ ---
        function moveSnake() {
            if (dx === 0 && dy === 0) return;
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };
            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                score++;
                const speedMultiplier = Math.max(0.1, Math.min(5.0, parseFloat(speedInput.value) || 1.5));
                gameSpeed += 0.15 * speedMultiplier;
                updateScoreDisplay();
                generateFood();
            } else {
                snake.pop();
            }
        }

        // --- ç»˜åˆ¶è›‡ï¼ˆä¸»è§’ï¼‰ ---
        function drawSnake() {
            const head = snake[0];
            if (playerImage && playerImage.complete) {
                ctx.drawImage(playerImage, head.x * gridSize, head.y * gridSize, gridSize, gridSize);
            } else {
                ctx.font = `${gridSize}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ğŸ¸', head.x * gridSize + gridSize / 2, head.y * gridSize + gridSize / 2);
            }
            ctx.fillStyle = '#4ade80';
            for (let i = 1; i < snake.length; i++) {
                ctx.beginPath();
                ctx.roundRect(snake[i].x * gridSize + 1, snake[i].y * gridSize + 1, gridSize - 2, gridSize - 2, [4]);
                ctx.fill();
            }
        }

        // --- ç»˜åˆ¶é£Ÿç‰© ---
        function drawFood() {
            if (foodImage && foodImage.complete) {
                ctx.drawImage(foodImage, food.x * gridSize, food.y * gridSize, gridSize, gridSize);
            } else {
                ctx.font = `${gridSize * 0.9}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ğŸ¦Ÿ', food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2);
            }
        }

        // --- ç”Ÿæˆé£Ÿç‰© (ä¸å…è®¸è´´è¾¹) ---
        function generateFood() {
            food = {
                x: Math.floor(Math.random() * (tileCount - 2)) + 1,
                y: Math.floor(Math.random() * (tileCount - 2)) + 1
            };
            for (const segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    generateFood(); return;
                }
            }
        }

        // --- ç¢°æ’æ£€æµ‹ ---
        function checkCollision() {
            const head = snake[0];
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) return gameOver();
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) return gameOver();
            }
        }

        // --- UI & çŠ¶æ€ç®¡ç† ---
        function updateScoreDisplay() { scoreEl.textContent = score; }
        function setControlsState(enabled) {
            speedInput.disabled = !enabled;
            playerIconInput.disabled = !enabled;
            foodIconInput.disabled = !enabled;
            tileCountInput.disabled = !enabled; // æ–°å¢
        }
        function startGame() {
            setupCanvas(); // åœ¨å¼€å§‹æ—¶æ ¹æ®æœ€æ–°è®¾ç½®é‡æ–°ç”Ÿæˆç”»å¸ƒ
            init();
            gameState = 'running';
            gameOverlay.style.display = 'none';
            setControlsState(false);
            window.requestAnimationFrame(gameLoop);
        }
        function gameOver() {
            gameState = 'gameOver';
            gameOverlay.style.display = 'flex';
            statusTitle.textContent = 'æ¸¸æˆç»“æŸ';
            statusSubtitle.textContent = `ä½ çš„æœ€ç»ˆå¾—åˆ†æ˜¯ ${score} åˆ†ï¼`;
            startBtn.textContent = 'é‡æ–°å¼€å§‹';
            setControlsState(true);
        }

        // --- æ–¹å‘æ§åˆ¶ ---
        function changeDirection(event) {
            if (gameState !== 'running' && !(dx === 0 && dy === 0)) return;
            const keyMap = { 37: 'left', 65: 'left', 38: 'up', 87: 'up', 39: 'right', 68: 'right', 40: 'down', 83: 'down' };
            const direction = keyMap[event.keyCode];
            const goingUp = dy === -1, goingDown = dy === 1, goingRight = dx === 1, goingLeft = dx === -1;
            if (direction === 'left' && !goingRight) { dx = -1; dy = 0; }
            if (direction === 'up' && !goingDown) { dx = 0; dy = -1; }
            if (direction === 'right' && !goingLeft) { dx = 1; dy = 0; }
            if (direction === 'down' && !goingUp) { dx = 0; dy = 1; }
        }
        
        // --- è§¦æ‘¸æŒ‰é’®æ§åˆ¶ ---
        function setupTouchControls() {
            const controls = {
                'btn-up': { dx: 0, dy: -1, going: () => dy === 1 }, 'btn-down': { dx: 0, dy: 1, going: () => dy === -1 },
                'btn-left': { dx: -1, dy: 0, going: () => dx === 1 }, 'btn-right': { dx: 1, dy: 0, going: () => dx === -1 },
            };
            for (const [id, dir] of Object.entries(controls)) {
                document.getElementById(id).addEventListener('click', () => {
                   if (gameState !== 'running' && !(dx === 0 && dy === 0)) return;
                   if (!dir.going()) { dx = dir.dx; dy = dir.dy; }
                });
            }
        }

        // --- å›¾ç‰‡åŠ è½½é€»è¾‘ ---
        function setupImageLoaders() {
            function loadImage(inputElement, imageVariableSetter) {
                const url = inputElement.value.trim();
                if (!url) { imageVariableSetter(null); return; }
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => imageVariableSetter(img);
                img.onerror = () => imageVariableSetter(null);
                img.src = url;
            }
            playerIconInput.addEventListener('input', () => loadImage(playerIconInput, (img) => playerImage = img));
            foodIconInput.addEventListener('input', () => loadImage(foodIconInput, (img) => foodImage = img));
        }

        // --- äº‹ä»¶ç›‘å¬ ---
        document.addEventListener('keydown', changeDirection);
        startBtn.addEventListener('click', startGame);
        window.addEventListener('resize', () => {
            setupCanvas();
            draw();
            gameState = 'waiting';
            gameOverlay.style.display = 'flex';
            statusTitle.textContent = 'å‡†å¤‡å¥½äº†å—?';
            statusSubtitle.textContent = `å±å¹•å°ºå¯¸å·²å˜åŒ–ï¼Œè¯·é‡æ–°å¼€å§‹`;
            startBtn.textContent = 'å¼€å§‹æ¸¸æˆ';
            setControlsState(true);
            init();
        });

        // --- å¯åŠ¨ ---
        setupCanvas();
        init();
        draw();
        setupTouchControls();
        setupImageLoaders();
        setControlsState(true);
        gameState = 'waiting';
    </script>
</body>
</html>
